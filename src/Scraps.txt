

-- | ==================================================== | --
-- | =============== Code Scraps           ============== | --
-- | ==================================================== | --

data AlphaBetaTree = Pnt GameState Val Alpha Beta [AlphaBetaTree]


pruneAB :: Depth -> GameTree -> AlphaBetaTree
pruneAB 0 (GTree x _)      = Pnt x (heuristicRefined x) 0 0 []
pruneAB n (GTree x kinder) = case x of
   State (Turn Player1) _ _ _ _ -> Pnt x maxi 0 0 children
   State (Turn Player2) _ _ _ _ -> Pnt x mini 0 0 children
   State (GameOver _) _ _ _ _   -> Pnt x (heuristicRefined x) 0 0 []
  where
    children  = (map (pruneAB (n-1)) kinder)
    maxi       = maximum kidValues
    mini       = minimum kidValues
    kidValues = map getABVal children

getABVal :: AlphaBetaTree -> Val
getABVal (Pnt _ val _ _ _) = val


-- Cuts the tree at off at an integer depth adding in leaf nodes
pruneDepth :: Depth -> GameTree -> GameTree
pruneDepth 0 (GTree x _)         = GTree x []
pruneDepth _ (GTree x [])        = GTree x []
pruneDepth n (GTree x children)  = GTree x (map (pruneDepth (n-1)) children)



-- | ==================================================== | --
-- | =============== Minimax w/ alpha beta ============== | --
-- | ==================================================== | --

type Alpha = Int
type Beta  = Int

-- A polymorphic tree structure
data NodeValTree e v = ValNode v [(e,NodeValTree e v)]

-- Tree with values only in leaves which keeps track of 
-- the moves as well as 
type FanGameTree = NodeValTree Move GameState

-- The minimax tree
data MMABTree = MMAB [(Move, MMABTree)]
                | Terminus Val

alphaBetaOne :: Course -> GameState -> Int -> Move
alphaBetaOne COMP1100 state depth = gMove (getMAB state depth)
alphaBetaOne COMP1130 _ _         = error "Not in COMP1130"

getMAB :: GameState -> Int -> (Val, Maybe Move)
getMAB state d = case state of 
   State (Turn Player1) _ _ _ _ -> maximize (genMMABTree d (fanGameTree state))
   State (Turn Player2) _ _ _ _ -> minimize (genMMABTree d (fanGameTree state))
   State (GameOver _) _ _ _ _   -> error "given a gameover"

gMove :: (Val, Maybe Move) -> Move
gMove (_, Just c)  = c
gMove (_, Nothing) = error "no move - failure of gMove"


-- |// Compute full tree \\| --
fanGameTree :: GameState -> FanGameTree
fanGameTree state = case (turnFinder state) of
  GameOver _ -> ValNode state []
  Turn _     -> ValNode state succr
    where
      succr   = map (fmap fanGameTree) states
      states = moveListToS (legalMoves state) state

-- helper that just grabs the turn from a state for the case statement
turnFinder :: GameState -> Turn
turnFinder (State t _ _ _ _) = t

-- recurses through a list of legalMoves and...
-- ...then pairs it with the resulting gamestate
moveListToS :: [Move] -> GameState -> [(Move,GameState)]
moveListToS l state = case l of
  [] -> []
  x:xs -> case (applyMove myC x state) of
    Just s  -> (x,s):(moveListToS xs state)
    Nothing -> moveListToS xs state

-- |// Prune tree and attach values to leaves \\| --
genMMABTree :: Depth -> FanGameTree -> MMABTree
genMMABTree d tree = case (d, tree) of
  (_,ValNode s [])  -> Terminus (heuristicVal s)
  (0,ValNode s _)  -> Terminus (heuristicVal s)
  (_,ValNode _ ys) -> MMAB (map (fmap (genMMABTree (d-1))) ys)





-- |// Initial bounds on the a/b values \\| --

maxB :: Val
maxB = 10000

minB :: Val
minB = -10000





-- |// Higher order function for max and min \\| --

-- Function called for player 1

maximize :: MMABTree -> (Val, Maybe Move)
maximize tree = maxiTree minB maxB tree Nothing

maxiTree :: Val -> Val -> MMABTree -> Maybe (Val, Move) -> (Val, Maybe Move)
maxiTree _ _ (Terminus val) _             = (val, Nothing)
maxiTree _ _ (MMAB []) Nothing            = error "error in the function maxiTree"
maxiTree _ _ (MMAB []) (Just (val, move)) = (val, Just move)
maxiTree a b (MMAB ((move,children):ys)) acc =
  if val > b
  then (val, Just move)
  else maxiTree newa b (MMAB ys) newAcc
  where 
    (val,_) = miniTree a b children Nothing
    newa    = max a val
    newAcc  = case acc of
      Nothing -> Just (val,move)
      Just (accVal,_) -> if val>accVal 
                        then Just (val,move)
                        else acc



-- Function called for player 2

minimize :: MMABTree -> (Val, Maybe Move)
minimize tree = miniTree minB maxB tree Nothing

miniTree :: Val -> Val -> MMABTree -> Maybe (Val, Move) -> (Val, Maybe Move)
miniTree _ _ (Terminus val) _             = (val, Nothing)
miniTree _ _ (MMAB []) Nothing            = error "error in the function mimiTree"
miniTree _ _ (MMAB []) (Just (val, move)) = (val, Just move)
miniTree a b (MMAB ((move,children):ys)) acc =
  if val <=a
  then (val, Just move)
  else maxiTree a newb (MMAB ys) newAcc
  where 
    (val,_) = miniTree a b children Nothing
    newb    = min b val
    newAcc  = case acc of
      Nothing -> Just (val,move)
      Just (accVal,_) -> if val<accVal 
                        then Just (val,move)
                        else acc


