\documentclass[11pt]{article}
\title{Technical Report\\ COMP1100 Assignment 3}
\author{Jacob Bos\\ ANU u7469354}

\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{array}
	\newcolumntype{L}{>{\centering\arraybackslash}m{15cm}}
\usepackage{float}
\usepackage{multicol}
\setlength{\columnsep}{1cm}
\usepackage{setspace}
\usepackage{xcolor}

\newenvironment{smallpmatrix}
  {\left(\begin{smallmatrix}}
  {\end{smallmatrix}\right)}
 \newenvironment{smol}
  {\left(\begin{smallmatrix}}
  {\end{smallmatrix}\right)}


\usepackage[margin=2cm]{geometry}
\addtolength{\textheight}{-0.5cm}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\begin{document}
\maketitle
\pagenumbering{roman}
\setstretch{1.5}
\begin{center}
  Lab: Tuesday 11am\\
  Tutor: Abhaas Goyal\\
  Word-count beyond cover page at $\leq 1500$ words
\end{center}
\tableofcontents
\newpage
\pagenumbering{arabic}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\section{Introduction} 
The program detailed herein is an implementation of a few AI's for solving the game Fanorona with complimentary unit tests.


%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\section{Documentation}%Explanation of code workings, functions and structure.
\subsection{Design Documentation and Technical Decisions}
% Describe what each relevant function does conceptually. (i.e. how does it get you closer to solving the problems outlined in this assignment spec?)
% How do these functions piece together to make the finished program? Why did you design and implement it this way?
% What major design choices did you make regarding the functions that youâ€™ve written and the overall structure of your program?
\paragraph*{First capture move} is little more complex than the provided \verb|firstLegalMove|, it is "content" with taking the head of the list of possible capturing moves as provided by the function \verb|captures| else returning the first legal move. This was used to test the greedy AI, because a greedy should on average perform better.

\paragraph{The Greedy AI} has a simple functionality. The main function \verb|greedy| cases on which player's turn it is given the provided gameState and chooses whether to maximize (Player1) or minimize (Player2) the heuristic value and calls \verb|greedyHelp| with the appropriate evaluator to output a pair containing the ideal move and its heuristic value. It does this by calling \verb|greedyHelp| which recurses through a list of moves and their values and either minimizes or maximizes it. This list is a mapping of the list provided by \verb|legalMoves| to a list of pairs of moves of each move with the value of the move created by the function \verb|diffPieces| applied to the \verb|applyMove| of the move and initial state.

\paragraph{Minimax} uses two recursive tree structures, the first \verb|GameTree|, stores all the possible gamestates and is generated through an infinite recursion in \verb|gameTree| which takes a state, puts it into a node and then maps \verb|gameTree| to all its children states which are generated through a mapping of \verb|applyMove| to a list of \verb|legalMoves| which is then recursively purged of its \verb|[Maybe GameState]| type by \verb|purge| to become \verb|[GameState]|.

\subparagraph*{}The second tree structure, \verb|evalTree| is the same as \verb|GTree| except that it contains a value on each node corresponding tpo the best possible outcome (heuristic value) for the player who's state is at that node and is pruned to a given \textit{move depth}. The \verb|evalTree| is generated by recursively by \verb|pruneMinMax| which cases firstly on integer depth given to the function, if the depth is zero then it evaluated the heuristic value at that node and then terminates that branch. If not, it then cases on the state held in the node, if the state contains a \verb|GameOver| turn then it does as if the depth was zero, terminating the tree. If the state at a node contains \verb|Turn Player1| then it assigns the maximum of the values in its child \verb|EvalTree| nodes else if the turn is the \verb|Player2|, the minimizing player, it assigns the minimum value of its child nodes to the given node. This results in the best possible outcome for the player in the initial state ending up in the head node.

\subparagraph*{}The heuristic value used is the difference in number of pieces between \verb|Player1| and \verb|Player2| and is calculated by \verb|heuristicVal| which takes the pair output of the provided \verb|countPieces| function and then takes the difference in the number of pieces.

\subparagraph*{}To then retrieve the best move we note that the best move is at the same depth in the \verb|legalMoves| list as best value stored in the head node is in the list of child \verb|evalTree| nodes. This is because the list of children nodes is produced by a mapping on the \verb|legalMoves| list. Consequently to find the best move we extract the value from the head of the output of \verb|pruneMinMax| using \verb|getVal| and then find it's depth recursively in the list provided by mapping \verb|getVal| to the child nodes at depth 1 using \verb|findDepth|. Consequently the function \verb|getMove| uses the (!!) operator to extract the best move at its expected depth in the \verb|legalMoves| list.


\paragraph{The other AI's} 

\newpage
\subsection{Program Design / Structure}


 \subsection{Assumptions}%Describe assumptions you have made about how a user might use the program and how this has influenced your design decisions.


%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

\section{Testing}%How did I test the program focus on methodology and testing groups
%How did you test individual functions?
%Be specific about this - the tutors know that you have tested your program, but they want to know how.
%Describe the tests that prove individual functions on their own behave as expected (i.e. testing a function with different inputs and doing a calculation by hand to check that the outputs are correct).
%How did you test the entire program? What tests did you perform to show that the program behaves as expected in all (even unusual) cases?
\paragraph{Unit tests} 
\paragraph{Performance tests} 
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~




\section{Reflection}
%Discuss the reasoning behind your decisions, rather than what the decisions were. You can reflect on not only the decisions you made, but the process through which you developed the final program:
   %What would you have done differently if you were to do it again
    %What changes to the design and structure you would make if you wrote the program again from scratch?
    \subsection{Design Choices}


   \subsection{Reflection}





%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\end{document}
